1. [说一下你最喜欢语言的三个缺陷](#1-shuo-yi-xia-ni-zui-xi-huan-yu-yan-de-san-ge-que-xian)
2. [为什么现在对函数式编程语言越来越受到欢迎？](#2-wei-shen-me-xian-zai-dui-han-shu-shi-bian-cheng-yu-yan-yue-lai-yue-shou-dao-huan-ying)
3. [什么是闭包，闭包有什么作用？它和类有什么区别？](#3-shen-me-shi-bi-bao-bi-bao-you-shen-me-zuo-yong-ta-he-lei-you-shen-me-qu-bie)
4. [什么是高阶函数？它是用来做什么的？用你最喜欢的语言写一个高阶函数;](#4-shen-me-shi-gao-jie-han-shu-ta-shi-yong-lai-zuo-shen-me-de-yong-ni-zui-xi-huan-de-yu-yan-xie-yi-ge-gao-jie-han-shu)
5. [编写一个循环，然后将它转换成递归的形式，并且只能使用不可变结构（比如避免使用变量）](#5-bian-xie-yi-ge-xun-huan-ran-hou-jiang-ta-zhuan-huan-cheng-di-gui-de-xing-shi-bing-qie-zhi-neng-shi-yong-bu-ke-bian-jie-gou-bi-ru-bi-mian-shi-yong-bian-liang)
6. [什么是栈和堆？什么叫栈溢出？](#6-shen-me-shi-zhan-he-dui-shen-me-jiao-zhan-yi-chu)
7. [命名空间（namespace)是做什么的？能够发明一个可替代性的东西？](#7-ming-ming-kong-jian-namespace-shi-zuo-shen-me-de-neng-gou-fa-ming-yi-ge-ke-ti-dai-xing-de-dong-xi)
8. [编写两个函数，一个是引用透明（Referentially Transparent)，另一个是引用不透明（Referentially Opaque）](#8-bian-xie-liang-ge-han-shu-yi-ge-shi-yin-yong-tou-ming-referentially-transparent-ling-yi-ge-shi-yin-yong-bu-tou-ming-referentially-opaque)
9. [为什么在有些语言设计中没有异常机制？那么它们有什么优势和弊端？](#9-wei-shen-me-zai-you-xie-yu-yan-she-ji-zhong-mei-you-yi-chang-ji-zhi-na-me-ta-men-you-shen-me-you-shi-he-bi-duan)
10. [为什么在JAVA，或者C#中，构造函数不是接口的一部分？](#10-wei-shen-me-zai-java-huo-zheczhong-gou-zao-han-shu-bu-shi-jie-kou-de-yi-bu-fen)
11. [泛型是用来做什么的？](#11-fan-xing-shi-yong-lai-zuo-shen-me-de)
12. [语言将函数当做一等公民意味什么？](#12-yu-yan-jiang-han-shu-dang-zuo-yi-deng-gong-min-yi-wei-shen-me)
13. [展示一个例子来说明匿名函数是有用的；](#13-zhan-shi-yi-ge-li-zi-lai-shuo-ming-ni-ming-han-shu-shi-you-yong-de)
14. [有许多不同的类型系统：静态类型和动态类型，强类型和弱类型等等。你能分享和讨论一下在开发一个企业级软件的时候，如何去选择特定的类型系统？](#14-you-xu-duo-bu-tong-de-lei-xing-xi-tong-jing-tai-lei-xing-he-dong-tai-lei-xing-qiang-lei-xing-he-ruo-lei-xing-deng-deng-ni-neng-fen-xiang-he-tao-lun-yi-xia-zai-kai-fa-yi-ge-qi-ye-ji-ruan-jian-de-shi-hou-ru-he-qu-xuan-ze-te-ding-de-lei-xing-xi-tong)
15. [讨论一下JAVA和C#之间的互通性？](#15-tao-lun-yi-xia-java-heczhi-jian-de-hu-tong-xing)
16. [为什么许多开发人员不喜欢JAVA？](#16-wei-shen-me-xu-duo-kai-fa-ren-yuan-bu-xi-huan-java)
17. [好语言的好和坏语言的坏各自在什么地方？](#17-hao-yu-yan-de-hao-he-huai-yu-yan-de-huai-ge-zi-zai-shen-me-di-fang)
18. [在一些语言中，尤其是函数化倾向的语言中，有一种叫模式匹配（Pattern Matching)的技术，那么在模式匹配和Switch语言有什么区别？](#18-zai-yi-xie-yu-yan-zhong-you-qi-shi-han-shu-hua-qing-xiang-de-yu-yan-zhong-you-yi-zhong-jiao-mo-shi-pi-pei-pattern-matching-de-ji-shu-na-me-zai-mo-shi-pi-pei-he-switch-yu-yan-you-shen-me-qu-bie)
19. [如果Cat是Animal，那么设计的时候是TakeCare还是TakeCare?](#19-ru-guo-cat-shi-animal-na-me-she-ji-de-shi-hou-shi-takecare-hai-shi-takecare)
20. [最近几年，有很多关于Node的不实的宣传，那么你对这些原本运行在浏览器中的语言用作后端开发语言的看法是什么?](#20-zui-jin-ji-nian-you-hen-duo-guan-yu-node-de-bu-shi-de-xuan-chuan-na-me-ni-dui-zhe-xie-yuan-ben-yun-hang-zai-liu-lan-qi-zhong-de-yu-yan-yong-zuo-hou-duan-kai-fa-yu-yan-de-kan-fa-shi-shen-me)
21. [假设你有一台时光机，能够穿梭到Java语言创建的时间点，并且能够和JDK的架构者交流，那么你将会说服他什么？比如移除检查异常（checked exception)机制?增加非符号的的基础类型？增加多继承？](#21-jia-she-ni-you-yi-tai-shi-guang-ji-neng-gou-chuan-suo-dao-java-yu-yan-chuang-jian-de-shi-jian-dian-bing-qie-neng-gou-he-jdk-de-jia-gou-zhe-jiao-liu-na-me-ni-jiang-hui-shuo-fu-ta-shen-me-bi-ru-yi-chu-jian-cha-yi-chang-checked-exception-ji-zhi-zeng-jia-fei-fu-hao-de-de-ji-chu-lei-xing-zeng-jia-duo-ji-cheng)


## 1 说一下你最喜欢语言的三个缺陷

C# 语言

1. 开源太晚

虽然说现在 `C#` 已经开源，但是面对互联网，云计算和大数据时代还是显得有点太晚了。在一些技术社区仍然以为 C# 知识 Windows Only 的开发语言。这个对于新的开发者而言是一个很错误的引导，而且吸引不了更多的开发者进入这个行业。而且在过去几年，C# 开发领域由很多令人困惑的概念，比如说 `.Net Core`, `.Net Standard`, `Mono`, `.Net 5` 以及传统的 `.Net Framework`。这些概念对于有经验的开发工程师都难以区分它们。

2. 复杂的比较操作

在 C# 中有很多比较操作，这些操作往往令开发者难以区分。

- 用户自定一个比较操作： `>`, `<`, `>=`,`==`,`!=`等等
- 重载 `Equals(object)` 这个方法
- `Object` 类中包含的 `Equals` 这个静态方法
- `IComparable` 接口
- `IEquality` 接口

3. 对接口限制太严格

对于接口，只能包含了方法和属性，不能包含字段，静态方法等等。

## 2 为什么现在对函数式编程语言越来越受到欢迎？

大部分应用程序在开发的过程中的缺陷主要是由软件开发者并没有完整的清楚代码在实际运行时候全部的状态。
尤其是在多线程运行环境中，这个问题就会被放大。通过函数式编程软件中所有的状态就会变得明确，同样使得
诸如多线程的条件竞争等问题得到解决。纯函数是函数式编程重要的内容，它只关注传递给他的参数，返回根据
传入的参数计算而得的值，没有逻辑上的副作用(`side effect`)。它不更新全局变量，不维持全局变量，
也不会进行IO操作，更不会修改传入的参数。纯函数的有一下几点优势

- 线程安全：纯函数只使用参数，所以它是完全线程安全的的；所以很容易地将这些函数改造成并行执行，尤其在多核CPU中发挥优势；
- 可重用性：将纯函数转移到新的环境非常简单，只需要处理类型定义和函数调用，不会发生类似滚雪球效应；
- 可测试性：纯函数是引用透明的，也就是说同样的参数调用无论如何都会返回正确的结果；
- 可理解性和可维护性：只关心参数的输入和结果的输出，大大降低了维护者的理解难度

## 3 什么是闭包，闭包有什么作用？它和类有什么区别？

闭包（Closure）是词法闭包（Lexical Closure）的简称，闭包提供了一种方位内部变量的一种方式。
程序设计中，每一个变量都有一定的作用域，作用域之外的将不能访问该该变量

```go
var a = 1

func func1() {
    var b = 10
    fmt.Printf("%d", a)
}

// error
func func2(){
    fmt.Printf("%d", b)
}
```

变量`a`是全局变量，所以对`func1`和`func2`都可见，但是变量`b`是局部变量，对于`func2`是不可见的，所以无法访问`b`。这是由`go`语言的"链式作用域"结构（`chain scope`）决定的。子对象会一级一级地向上寻找所有父对象的变量，所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
但是闭包提供了方位局部变量的方法：

```go
func func3() func() {
    var c = 10
    return func(){
        c++
        fmt.Printf("%d", c)
    }
}
handler := func3()
handler() // 11
handler() // 12 
```

在`go`语言中，函数是一等公民(`first class citizen`)，所以`func3`可以返回一个函数。该函数包含了局部变量`c`，所以在外面就可以访问`c`变量的方式。
使用闭包的可以减少变量的使用，使用局部变量就可以保存全部的状态。

## 4 什么是高阶函数？它是用来做什么的？用你最喜欢的语言写一个高阶函数;

如何一个函数接受另一个函数作为参数或者返回函数，那么这个函数就是高阶函数。
高阶函数能够表达出更强的抽象。

```go
func twice(f func(int) int, v int) int {
	return f(f(v))
}

func main() {
	f := func(v int) int {
		return v + 3
	}
	twice(f, 7) // returns 13
}
```

## 5 编写一个循环，然后将它转换成递归的形式，并且只能使用不可变结构（比如避免使用变量）

```go
func factorialInter(n int) int {
    val := 1
    for i:=1; i<n; i++ {
        val = val * i
    }
    return val
}

func factorialRec(n int, val int) int {
    if n = 1 {
        return val
    }else{
        return factorialRec(n-1, val*n)
    }
}
```

## 6 什么是栈和堆？什么叫栈溢出？

由于虚拟内存的设计，每一个应用程序 "仿佛" 使用了全部机器的内存，一般来讲程序内存划分情况如下图:

![内存](images/memory.png)

- 地址 `0xffffffff - 0xc0000000` 为内核地址；
- 地址 `0x08048000` 往上为程序的只读段，主要包含了代码段，只读数据段，再往上为数据段；
- 再往上为堆，所有程序中手动分配的内存将在这个位置开始往上分配；
- 地址 `0x40000000` 往上一部分为动态共享库；
- 地址 `0xc0000000` 往下为栈空间。

操作系统为为每一个函数调用提供了栈帧，主要保存函数的参数、返回地址和一些局部变量。如果程序设计不当，将会导致栈帧使用完毕，导致栈溢出，常见的主要有无限递归。

## 7 命名空间（namespace)是做什么的？能够发明一个可替代性的东西？

在编程领域中，命令空间主要解决变量，函数以及类它们之间的冲突。假设你的应用程序使用了两个库。

```C#
// library A 
public class FooBar 
{
    //...
}

// library B
public class FooBar
{
    //...
}
```
我们可以看到，`FooBar` 两个类出现了两个库，我们的应用程序编译器不能区分它们，所以我们引入了命名空间。

```C#
// libray A
namespace Tindo.SDK
{
    public class FooBar {}
}

// library B
namespace Aurisoft.Tool
{
    public class FooBar {}
}
```

现在我们就能很好的区分它们，不会发生对象解析错误。

如果我们能够解析冲突，就不需要命令空间。我们可以为每个库的对象能唯一值标记即可。

```C#
// libaray A -> libraryA.dll
public class FooBar {}

// library B -> libraryB.dll
public class FooBar {}


// programa
using FooBarA = import("libraryA.dll", "FooBar");
using FooBarB = import("libraryB.dll", "FooBar");

```

## 8 编写两个函数，一个是引用透明（`Referentially Transparent`)，另一个是引用不透明（`Referentially Opaque`）

首先什么是引用透明呢? 它用来描述定义一个表达式的事实，在一个程序中，如果一个表达式可以被一个具体的值取代而不影响结果那么我们就可以称为改引用透明，从某种程度来讲就是改表达式由特定的参数输入一定会输出相同的结果，这是函数式编程的概念。

假设我们由下面几个函数

```C#
int Add(int a, int b){
    return a + b;
}

int Mult(int a, int b){
    return a * b;
}

int x = Add(2, Mult(3, 4));
```

在上面的例子中， `Mult` 函数就是引用透明的，因为我们可以用 `12` 替换掉 `Mult(3, 4)` 而不会有任何影响；同样我们也可以用 `14` 替换 `Add(2, 12)`。

下面再介绍一下引用不透明的例子 

```C#
int Add(int a, int b){
    int result = a + b;
    Console.WriteLine($"Returning {result}");
    return result;
}
```

如果我们用特定的值替换 `Add` 方法，那么 `Returning` 方法就不会输出，产生了副作用 (Side Effect）。有些情况下，非但带来了副作用，而且导致的结果也不正确。

```C#
class Fibs {
    private int previous = 1;
    private int last = 1;

    public int Next() {
        last = previous + (previous = last);
        return prevous + last;
    }
}

public void PrintFibs(int limit){
    Fibs fibs = new Fibs();
    for(int i =0; i < limit; i++){
        Console.WriteLine(fibs.Next());
    }
}
```

在这里我们不能用任何值代替 `Next` 方法的调用，因为这个方法在每次调用的时候就是不一样的。


## 9 为什么在有些语言设计中没有异常机制？那么它们有什么优势和弊端？

异常的设计是随着语言的发展而发展的，在早期的语言，比如汇编语言并没有应用程序层面的异常，只需要顺序和跳转两中执行控制语句就可以完成全部的工作。现代语言通常封装了底层的逻辑，因此也提供了大量的高级的语言的特性，所以异常自然而然提出。

**优势** 
- 异常可以将错误处理代码和正常的逻辑流区分开来，这样代码就可以很容易的阅读，健壮和可拓展性

举个例子如下

使用异常处理
```c++
// sample 1: A function that uses exceptions
string get_html(const char* url, int port)
{
    Socket client(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    client.connect(url, port);
    
    stringstream request_stream;
    request_stream << "GET / HTTP/1.1\r\nHost: " 
       << url << "\r\nConnection: Close\r\n\r\n";

    client.send(request_stream.str());

    return client.receive();
}
```

如果使用错误代码

```c++
// sample 2: A function that uses error codes
Socket::Err_code get_html(const char* url, int port, string* result)
{
    Socket client;
    Socket::Err_code err = client.init(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (err) return err;
        
    err = client.connect(url, port);
    if (err) return err;
    
    stringstream request_stream;
    request_stream << "GET / HTTP/1.1\r\nHost: " << url 
       << "\r\nConnection: Close\r\n\r\n";

    err = client.send(request_stream.str());
    if (err) return err;

    return client.receive(result);
}
```

上面的两个例子都是完成同样的事情，但是从错误处理的版本来看，代码需要处理很多错误的情况，使代码的可读性不高。

- 只有抛出异常才能解决构造函数的的错误

在类的构造函数中，通常需要申请一些系统资源，如果申请失败，就会让对象处于不稳定的状态。如果使用错误处理就不能处理这种情况。

- 异常很难被忽略

对于没有捕获的异常，系统就会 crash 掉，这个有助于系统维护者更早的发现发现问题，解决问题，而不是忽略它们。但是对于错误处理这种方式，就很难做到。

- 异常可以从嵌套的函数中传播出来

使用异常可以很方便地将错误从发生地地方到最外面调用地地方。

- 异常可以使用自定义地类型，它们可以比错误代码包含更多地信息

通常错误代码使用整型，而且没有更多的信息。当然可以为错误代码设计为一个 Object，但是需要复制很多次这种对象。但是异常的话，本身就是一个对象，而且可以通过类型系统来处理它们。

```c++
// Exception  handler

void AppDialog::on_button()
{
    try {
        string url = url_text_control.get_text();
        result_pane.set_text(
            get_title(url));
    }
    catch(Socket::SocketConnectionException& sock_conn_exc) {
        display_network_connection_error_message();
    }
    catch(Socket::Exception& sock_exc) {
        display_general_network_error_message();
    }
    catch(Parser::Exception& pars_exc) {
        display_parser_errorMessage();
    }
    catch(...) {
        display_unknown_error_message();
    }
}
```

通过异常类型的条件，处理不同的情况。

**劣势**

- 异常为代码逻辑增加了很多不可见的退出点，这样的增加的代码检查的难度。

以为异常可以跳出正在正在执行的逻辑代码流，所以在无形之中为代码函数增加了退出的机制

- 异常可能导致资源泄露，尤其使没有内置垃圾回收的编程语言

由于异常可以提前退出整个代码逻辑，所以可能导致已经分配系统资源的没有执行释放代码。

- 异常的发生会导致性能上的损失

众所周知，异常对系统的性能是由损失的。

## 10 为什么在JAVA，或者C#中，构造函数不是接口的一部分？

构造函数是特殊的成员函数方法用来初始化新创建的对象，它会在类对象创建的时候自动被调用。但是构造函数并不是接口的一部分。

- 接口是类的完全的抽象，在 Java 中接口中的所有的数据成员都是默认 `public`, `static` 并且 `final` 修饰的。所有的静态字段必须在声明的时候就应当赋值，否则就会出现编译的时候错误。

- 接口中的方法都是默认 `public` 的，而且也是 `abstract` 这就意味着在接口中不应当提供具体的实现，应当由实现接口的类来完成这部分工作。因此，没有必要再接口中包含一个构造方法。

- 构造函数用来初始化非静态的数据成员，因为在接口中没有非静态的数据成员，所以没有构造函数的必要。

- 接口中的方法只有声明没有定义，由于没有方法的具体实现，所以没有必要有一个对象来调用方法同样也不会有构造函数。

## 11 泛型是用来做什么的？

泛型编程主要是解决下面三个问题

1. 算法的泛型；
2. 类型的泛型；
3. 数据结构的泛型。

假设我们这里有一个 `Search` 的方法，它的主要作用是在一个集合中查找一个特定的元素

```C

int search(void* a, size_t size, void* target, 
  size_t elem_size, int(*cmpFn)(void*, void*) )
{
  for(int i=0; i<size; i++) {
    if ( cmpFn (a + elem_size * i, target) == 0 ) {
      return i;
    }
  }
  return -1;
}
```

这里 `C` 语言实现有个重要的问题是它不适用非线性数据结构，比如像哈希表，二叉树等等，算法返回的索引值并没有实际意义，而且 `i++` 也没有具体的意义。

那么如果使用 `C++` 模板的泛型来实现是怎样的的？

```C++

template<typename T, typename Iter>
Iter search(Iter pStart, Iter pEnd, T target) 
{
  for(Iter p = pStart; p != pEnd; p++) {
    if ( *p == target ) 
      return p;
  }
  return NULL;
}
```

这里有个泛型参数
- T 用来表示集合中数据的类型
- Iter 用来表示迭代器，从而支持了不同集合的类型。

这个也是 `C++` 的 `STL` 使用的泛型方法，其中包括了
- 泛型的数据容器
- 泛型数据容器的迭代器
- 泛型的算法

泛型还解决了更高维度的抽象，因为我们希望这个算法只管遍历，具体要干什么，那么业务逻辑，由外面的调用方法定义就好了，这样代码的重用度就提高了。

```C++
template<class Iter, class T, class Op>
T reduce (Iter start, Iter end, T init, Op op) {
  T result = init;
  while ( start != end ) {
    result = op( result, *start );
    start++;
  }
  return result;
}
```

这里整个迭代器传入了一个 `operation`, 在迭代的每一步都是由传入的操作完成。在定义了这个 `reduce` 函数后，我们可以从 `Employees` 列表中获取总薪水和最高薪水。

```C++
double sum_salaries = 
    reduce(staff.begin(), staff.end(), 0.0,
    [](double s, Employee e) { return s + e.salary; });

double max_salary = 
    reduce(staff.begin(), staff.end(), 0.0,
    [](double s, Employee e) { return s > e.salary ? s : e.salary; });
```


## 12 语言将函数当做一等公民意味什么？

*todo*

## 13 展示一个例子来说明匿名函数是有用的；

*todo*

## 14 有许多不同的类型系统：静态类型和动态类型，强类型和弱类型等等。你能分享和讨论一下在开发一个企业级软件的时候，如何去选择特定的类型系统？

*todo*

## 15 讨论一下JAVA和C#之间的互通性？

*todo*

## 16 为什么许多开发人员不喜欢JAVA？

*todo*

## 17 好语言的好和坏语言的坏各自在什么地方？

*todo*

## 18 在一些语言中，尤其是函数化倾向的语言中，有一种叫模式匹配（Pattern Matching)的技术，那么在模式匹配和Switch语言有什么区别？
在计算机科学中，模式匹配是一种行为，它用来检查一系列 `Token` 是否满足特定的模式条件，它只有**是/否**的两种选择。

假设你熟悉 `if` 和 `Switch` 编程语法，接下来我们以 `C#` 编程语言支持的模式匹配为例。我们现有有不同的几何图形的类，但是不同于之前的继承关系，我们并没有引入这些概念。

```C#
public class Square
{
    public double Side { get; }

    public Square(double side)
    {
        Side = side;
    }
}
public class Circle
{
    public double Radius { get; }

    public Circle(double radius)
    {
        Radius = radius;
    }
}
public struct Rectangle
{
    public double Length { get; }
    public double Height { get; }

    public Rectangle(double length, double height)
    {
        Length = length;
        Height = height;
    }
}
public class Triangle
{
    public double Base { get; }
    public double Height { get; }

    public Triangle(double @base, double height)
    {
        Base = @base;
        Height = height;
    }
}
```

现在我们有四个集合图形的类，需要来提供了公共的方法来计算它们的面积。

**方案1**

采用 `is` 表达式，这是最经典的表达，通过判断传入的类型来分别计算。

```C#
public static double ComputeArea(object shape)
{
    if (shape is Square)
    {
        var s = (Square)shape;
        return s.Side * s.Side;
    }
    else if (shape is Circle)
    {
        var c = (Circle)shape;
        return c.Radius * c.Radius * Math.PI;
    }
    // elided
    throw new ArgumentException(
        message: "shape is not a recognized shape",
        paramName: nameof(shape));
}
```

**方案2**

使用 `Switch` 表达式，在之前的 `C#` 语法中，每个 `Switch` 中的条件都是常量，而且只能是数字和 `String` 类型。

```C#
public static string GenerateMessage(params string[] parts)
{
    switch (parts.Length)
    {
        case 0:
            return "No elements to the input";
        case 1:
            return $"One element: {parts[0]}";
        case 2:
            return $"Two elements: {parts[0]}, {parts[1]}";
        default:
            return $"Many elements. Too many to write";
    }
}
```

但是在模式匹配中，这些限制条件被放开了，只需要每个 `case` 中的表达式能够返回 `True/False` 即可

```C#
public static double ComputeAreaModernSwitch(object shape)
{
    switch (shape)
    {
        case Square s:
            return s.Side * s.Side;
        case Circle c:
            return c.Radius * c.Radius * Math.PI;
        case Rectangle r:
            return r.Height * r.Length;
        default:
            throw new ArgumentException(
                message: "shape is not a recognized shape",
                paramName: nameof(shape));
    }
}
```

在这里，每个 `case` 语句不再是限制为 `int` 和 `string`, 而是一个个判断条件。

通过模式匹配，避免了冗长繁琐的 `if-else` 比较操作，而且丰富的程序的表达形式。


## 20 如果Cat是Animal，那么设计的时候是TakeCare<Cat>还是TakeCare<Animal>?
*todo*

## 21 最近几年，有很多关于Node的不实的宣传，那么你对这些原本运行在浏览器中的语言用作后端开发语言的看法是什么?

*todo*

## 22 假设你有一台时光机，能够穿梭到Java语言创建的时间点，并且能够和JDK的架构者交流，那么你将会说服他什么？比如移除检查异常（checked exception)机制?增加非符号的的基础类型？增加多继承？

*todo*