# 在面向对象编程中，一个很重要的目标是高内聚（High Cohesion)和松耦合（Loose Coupling). 那么它意味着什么？为什么这个很重要？如何实现它呢？

**内聚**用来度量一个软件的组成部分所专注的内容或者职责；**耦合**用来判定一个软件组成部分与其他部分的联系程度。软件的组成成分可以是类，包，组件，子系统或者完成的系统，然后在设计系统的时候，都会建议软件的各个组成拥有高内聚和松耦合。

低内聚将会导致巨大的类将会非常难以维护和理解，并且降低了可读性；同样的，紧耦合导致类之间紧紧联系在一起，每次改动都会涉及到其他的，导致难以改动和重用。

我们假设一个场景，设计一个可监控的类`ConnectionPool`，虽然它看上非常像一个简单的`ConnectionPool`，但是它的主要目的是演示如何实现高内聚和松耦合。它将有如下的功能：
1. 支持获取一个连接；
2. 释放一个连接；
3. 获取连接使用情况统计；
4. 获取连接时间统计；
5. 保存连接获取和释放信息，并统计汇报；

我们使用低内聚，设计出如下的`ConnectionPool`类，它生硬地将上述的所有功能和职责装入到一个类中，如下图所示，从中可以看出，
单个类包含连接管理，与数据库交互和维护连接状态等所有信息
![](./images/cp1.jpg)

使用高内聚，我们可以将这些职责分配给不同的类，来让他们更加可维护和可重用。
![](./images/cp2.jpg)

为了演示松耦合，我们继续使用紧耦合来设计`ConnnectinPool`，如果我们仔细看看上面的示意图，虽然它支持了高内聚，但是`ConnectionPool`仅仅地和`ConnectionStatistics`和`PersistentStore`两个类直接联系在一起。为了降低耦合，我们引入了`ConnectionListener`接口，让两个类分别实现这个接口，并且注册到`ConnecitonPool`类中。`ConnecitonPool`将会迭代这些监听器并且通知这些连接设置和释放事件，通过这样来完成解耦。
![](./images/cp3.jpg)

**注意点：**对于上述简单的场景，这个看上去好像有点过于设计，但是我们想象一下如果在真实的场景中，如果我们的应用程序需要和许多第三方的服务来完成事务，将我们的代码和第三方服务的进行直接耦合在一起也就意味着第三方服务的任何改变都会导致我们自己的代码发生改变，所以我们可以需要`Facade`设计模式来将我们的代码和不同的第三方服务隔离开来。

# 为什么在大部分语言中数组的下标从`0`开始？
大部分程序语言中，比如C/C++, Java等的数组都是从0开始，数组最后一个索引的为数组的长度减去1。对大部分程序开发人员而言，这个算是习以为常了。为什么数组的索引从0开始呢？这个与程序语言设计有关，比如在`C`语言中，数组的名字本质上就是指针，指向内存开始的位置，所以表达式`array[n]`表示为内存位置离数组开始位置，也就是偏移量。所以第一个元素也就是在数组的名字指向的位置，所以采用`array[0]`表示数组的第一个元素。
`Dijkstra`曾经解释过为什么数组从`0`开始，问题在于我们如何表示自然数，比如`1,2,3,...,10`，我们有四种可行的方案:
- a. `0<i<11`
- b. `1<=1<11`
- c. `0<i<=10`
- d. `1<=i<=10`

`Dijkstra`提出了表示表示应该可以表示下面两种情况：
1. 序列必须包含最小的自然数`0`
2. 序列应该是空的
第一个情况要求我们排除`a`和`c`，当然也可以使用，当然也可以使用`-1<i`来表示，不过这个太丑陋了；第二个情况可以排除`d`，剩下的就是`b`方案，而且两端相减就是序列的长度。
所以当你写如下的代码
```c
for (i=0; i < N; i++){
    sum += a[i]
}
```
这个代码就遵循了上述的语言设计规则。


# 内聚和耦合有什么区别？

- **内聚** 用来度量一个软件的组成部分所专注的内容或者职责
- **耦合** 用来判定一个软件组成部分与其他部分的联系程度。软件的组成成分可以是类，包，组件，子系统或者完成的系统，然后在设计系统的时候，都会建议软件的各个组成拥有高内聚和松耦合。


# 重构的作用是怎样的？

重构是一种提高现有代码设计的的控制手段，在功能保证前提下代码形式改变。但是这样累积而成改变的代码是非常重要的。通过这样微小的改变可以避免引入错误。这样也可以避免因为重建系统将整个系统垮掉，可以在长时间段将整个系统渐进式改变。
在重构的时候要注意到如下

- 在修改之前和之后，所有的单元测试必须通过；
- 应该没有必要修改和增加任何测试；
- 在完成之后，必须要让代码更加清晰；
- 应该不能增加新的功能

# 代码中注释是有用吗？一些人说我们应该尽可能的避免注释，而且它们大部分是无用的，你同意吗？

好的代码应该是 `self-document`，也就是说通过代码完成注释所需要的工作。注释应该要遵循以下规范

- 注释应该解释它做了什么；
- 注释应该解释它是如何完成它所需要的做内容；
- 注释应该解释为什么它是这样的；
- 对于变量和常量，注释应该关注它的内容而不是目的；
- 对于公共`API`必须增加文档注释；
- 对于糟糕的代码，去重写它，而不是添加注释；
- 对于做出修改的代码，必须重新注释，错误的注释比没有注释更加糟糕；


# 为什么测试驱动开发`TDD`中的测试时在开发之前？
- 在开发之前创建测试，可以很好的帮助开发人员考虑具体需要完成什么；
- 开发人员在完成功能后，可以立即得到反馈；
- 对于系统设计也有帮助，测试先行可以对所有不同阶段的开发人员进行约束；
- 通过一个个测试添加，对系统开发完成节奏有帮助；

# 在存储过程中使用领域逻辑有什么好处和坏处？
存储过程在处理比较复杂的业务的时候比较实用，具体分为两个方面
1. 响应时间：如果前台处理的话，可能涉及到多次数据库连接，但是如果实用存储过程的话，只需要一次数据库连接。
2. 安全性：存储过程的系统更加稳定，而应用程序容易出现 BUG 而不稳定，存储过程如果数据库不出现问题，就不会有问题。

但是存储过程往往定制化于特定的数据库上，因为支持的编程语言不通，当切换到其他厂商的数据库的时候，需要重写原有的存储过程。而且存储的性能调校与撰写，受限于各种数据库系统。

# 在你观点来看，使用面向对象编程为什么能够占据市场这么长时间？

面向对象编程(`Object Oriented Programming`)开始于1980s，其包含了三大主要特性也是其目前流行的主要
原因。

- 封装 (encapsulation)

面向对象将数据和方法封装起来，通过控制符来控制它们的可访问性。对于面向过程的语言中，如果一个变量被越多的函数
能够访问，就越变得难以掌控，当程序变得越来越大，就会导致整个系统越发难以维护。现代软件系统通常包含的代码量非常大，
面向过程编程减低了开发效率，而面向对象降低了开发的门槛，提高了开发进度。

- 继承 (inherition)
  
继承的好处是让我们能够重用我们已有的代码，子类能够使用父类的方法，并且增加自己特有的方法。随着GUI兴起，面向对象
编程处理起来更加得心应手，对GUI控件对象继承体系，大大地降低开发的难度，并且提供了自定义控件开发的基础。

- 多态 (polymorphism)

子类通过重载(`override`)父类的同名方法，达到不同的行为的目的。接口是多态的一种展示形式，每个实现接口的对象，可以完成
各自的所需的行为，这也是各种设计模式精髓所在。

但是目前针对面向对象编程也出现了一些反对面向对象编程的声音，主要有以下几点

1. 虽然面向对象编程封装了数据和方法，但是所有的操作仍然也是命令式(`imperative`)语句，而不是声明式(`declarative`)语句。这样对于并行编程(`parallel programming`)不够优化

2. 状态(`state`)是邪恶的，包含状态的程序非常难以并行运行，而面向对象编程非常鼓励可变性(`mutablility`)。

3. 在现实世界面向对象编程中，常常很少包含真正的实体名称，常常将一些所谓动词来冒充名词：比如`策略`, `工厂`或者`命令`。

4. 组合往往比继承更好地方式来编程，继承往往是增加的概念上复杂度。
